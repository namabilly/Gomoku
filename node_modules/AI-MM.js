const gomoku = require('gomoku');

const directions = [[1, 0], [0, 1], [1, 1], [1, -1], [-1, 1], [-1, -1], [0, -1], [-1, 0]];

class AI {
	constructor(name){
		this.g = gomoku.game;
		this.socket = gomoku.socket;
		this.name = name;
		//this.init();
		this.count = 0;
		this.weights = {
			op2: 10,
			cl2: 1,
			op3: 100,
			cl3: 10,
			op4: 1000,
			cl4: 110,
			op5: 10000,
			cl5: 10000,
			just5: 10000
		};
		this.id = 0;
	}
	init(){
		this.g.joinGame(this.name);
	}
	connect(id){
		this.socket.disconnect();
		this.socket.connect();
		this.g.init();
		this.g.side = 0;
		this.g.turn = 0;
		this.g.status = 0;
		this.g.joinGame(this.name);
		this.socket.emit('joinGame', {id: id});
		this.id = id;
	}
	disconnect(){
		this.socket.emit('watchGame', this.id);
	}
	run(){
		var that = this;
		var myDelay = 1000;
		var thisDelay = 1000;
		var start = Date.now();
		var loop = setTimeout(function(){
			
			if (that.g.status!==0) {
				//return that.g.status;
				that.g.side = 0;
				that.g.turn = 0;
				that.g.matrix = [];
				clearTimeout(loop);
				that.socket.disconnect();
				return;
			}
			if (that.g.turn%2*2-1===that.g.side) {
				console.log('My turn. Current board score: ' + that.score(that.g.matrix));
				//gomoku.socket.emit('newMessage', 'My turn');
				if (that.g.turn===0) {
					that.g.put({
						x: 7,
						y: 7
					})
				}
				else {
					var val = that.score(that.g.matrix);
					console.log(val);
					var move = that.choose();
					console.log(move);
					that.g.put({x:move.x, y:move.y});
					that.lastMove = {
						x: move.x,
						y: move.y,
						side: that.g.side
					};
					that.count = 0;
				}
			}
			else {
				var score = that.score(that.g.matrix);
				console.log('Enemy\'s turn. Current board score: ' + score);
				//gomoku.socket.emit('newMessage', 'Enemy\'s turn');
				if (that.count < 1 && score >= 800) {
					console.log('^_^');
					gomoku.socket.emit('newMessage', '^_^');
					that.count++;
				}
				if (that.count < 1 && score <= -100) {
					gomoku.socket.emit('concede');
					gomoku.socket.emit('newMessage', 'I had you, it\'s just so that you can play with me more.');
					that.count++;
				}
			}
			var actual = Date.now() - start;
			thisDelay = myDelay - (actual - myDelay);
			console.log(thisDelay);
			start = Date.now();
			that.run();
		}, thisDelay);
	}
	evaluate(side, matrix){
		if (side===0) return 0;
		var val = 0;
		var patterns = {
			op2: 0,
			cl2: 0,
			op3: 0,
			cl3: 0,
			op4: 0,
			cl4: 0,
			op5: 0,
			cl5: 0,
			just5: 0
		};
		var tt = [];
		for (let x=0;x<15;x++) {
			tt[x] = [];
			for (let y=0;y<15;y++) {
				tt[x][y] = true;
			}
		}
		// find patterns
		for (let x=0;x<15;x++) {
			for (let y=0;y<15;y++) {
				if (matrix[x][y]===side) {
					for (let i in directions) {
						var d = directions[i];
						if (matrix[x+d[0]]&&tt[x+d[0]][y+d[1]]&&matrix[x+d[0]][y+d[1]]===side) {
							var len = 2,
								flag = 0,
								xx = x+d[0],
								yy = y+d[1];
							while (matrix[xx+d[0]]&&tt[xx+d[0]][yy+d[1]]&&matrix[xx+d[0]][yy+d[1]]===side) {
								len++;
								xx += d[0];
								yy += d[1];
							}
							if (matrix[xx+d[0]]===undefined)
								flag++;
							else if (matrix[xx+d[0]]&&matrix[xx+d[0]][yy+d[1]]===-side)
								flag++;
							else if (!tt[xx+d[0]][yy+d[1]]) {
								continue;
							}
							/*
							else if (matrix[xx+d[0]*2]&&matrix[xx+d[0]*2][yy+d[1]*2]===side) {
								if (len < 4) {
									len++;
									flag = 'cl';
								}
							}
							*/
							//console.log(xx+d[0]+' '+yy+d[1]+' '+matrix[xx+d[0]][yy+d[1]]);
							xx = x;
							yy = y;
							d = directions[7-i];
							while (matrix[xx+d[0]]&&tt[xx+d[0]][yy+d[1]]&&matrix[xx+d[0]][yy+d[1]]===side) {
								len++;
								xx += d[0];
								yy += d[1];
							}
							if (matrix[xx+d[0]]===undefined) {
								if(flag!=='cl') flag++;
							}
							else if (matrix[xx+d[0]]&&matrix[xx+d[0]][yy+d[1]]===-side) {
								if(flag!=='cl') flag++;
							}
							else if (!tt[xx+d[0]][yy+d[1]]) {
								continue;
							}
							/*
							else if (matrix[xx+d[0]*2]&&matrix[xx+d[0]*2][yy+d[1]*2]===side) {
								if (flag!=='cl'&&len<4) {
									len++;
									flag = 'cl';
								}
							}
							*/
							if (len >= 5) {
								patterns['just5']++;
							}
							if (flag===0) flag = 'op';
							else if (flag===1) flag = 'cl';
							else continue;
							if (len > 5) len = 5;
							/*
							if (this.g.turn%2*2-1===-this.g.side) {
								console.log(x, y, flag, len);
							}
							*/
							patterns[flag+len]++;
						}
					}
					tt[x][y] = false;
				}
			}
		}
		//console.log(side, patterns);
		// calculate value with weights
		for (let i in patterns) {
			val += patterns[i]*this.weights[i];
		}
		// adjust value
		if (patterns['cl4']>=2) val += 800;
		else if (patterns['op3']>=2) {
			if (patterns['cl4']===1) val += 1000;
			else val += 500;
		}
		else if (patterns['op3']+patterns['cl4']>=2) val += 800;
		if (this.g.turn%2*2-1===-this.g.side && val > 1000) {
			//console.log(side, patterns);
		}
		return val;
	}
	score(matrix){
		return this.evaluate(this.g.side, matrix) - this.evaluate(-this.g.side, matrix);
	}
	scoreM(move, matrix){
		return Math.max(this.scoreP(move, matrix), this.scoreP({x:move.x, y:move.y, side:-move.side}, matrix));
	}
	scoreP(move, matrix){
		var x = move.x,
			y = move.y,
			side = move.side,
			patterns = {
				op2: 0,
				cl2: 0,
				op3: 0,
				cl3: 0,
				op4: 0,
				cl4: 0,
				op5: 0,
				cl5: 0,
				just5: 0
			};
		for (let i in directions) {
			var d = directions[i],
				xx = x,
				yy = y,
				len = 1,
				flag = 0;
			if (matrix[xx+d[0]]===undefined||matrix[xx+d[0]][yy+d[1]]!==side)
				continue;
			while (matrix[xx+d[0]]&&matrix[xx+d[0]][yy+d[1]]===side) {
				len++;
				xx += d[0];
				yy += d[1];
			}
			if (matrix[xx+d[0]]===undefined) {
				flag++;
			}
			else if (matrix[xx+d[0]][yy+d[1]]===-side) {
				flag++;
			}
			// jump
			/*
			else if (matrix[xx+d[0]][yy+d[1]]===0) {
				xx += d[0];
				yy += d[1];
				while (matrix[xx+d[0]]&&matrix[xx+d[0]][yy+d[1]]===side) {
					len++;
					xx += d[0];
					yy += d[1];
					flag = -1;
				}
			}
			*/
			d = directions[7-i];
			xx = x;
			yy = y;
			while (matrix[xx+d[0]]&&matrix[xx+d[0]][yy+d[1]]===side) {
				len++;
				xx += d[0];
				yy += d[1];
			}
			if (matrix[xx+d[0]]===undefined) {
				flag++;
			}
			else if (matrix[xx+d[0]][yy+d[1]]===-side) {
				flag++;
			}
			if (len >= 5&&flag!==-1) return 100000;
			if (flag===0||flag===-1) flag = 'op';
			else if (flag===1) flag = 'cl';
			else continue;
			patterns[flag+len]++;
		}
		var val = 0;
		for (let i in patterns) {
			val += patterns[i]*this.weights[i];
		}
		// adjust value
		if (patterns['cl4']>=2) val += 800;
		else if (patterns['op3']>=2) {
			if (patterns['cl4']===1) val += 1000;
			else val += 500;
		}
		else if (patterns['op3']+patterns['cl4']>=2) val += 800;
		return val;
	}
	choose(){
		/*
		var node = new Node({
			x: 0,
			y: 0,
			side: this.g.matrix[0][0]
		});
		*/
		if (!this.lastMove) {
			this.lastMove = {
				x: 7,
				y: 7,
				side: this.g.matrix[7][7]
			};
		}
		var node = {
			val: 0,
			move: this.lastMove
		};
		//node.level = 0;
		this.counter = 0;
		var depth = 6;
		if (this.g.turn >= 5) depth = 8;
		
		// deeping
		for (var i=2;i<=depth;i+=2) {
			this.minimax(node, i, -Infinity, Infinity, this.g.matrix);
			this.g.matrix[this.lastMove.x][this.lastMove.y] = this.lastMove.side;	
			if (node.val >= 800) break;
		}
		
		//this.generate(node, this.g.side, depth, this.g.matrix);
		
		console.log('Node count:', this.counter);
		var val = node.val;
		//console.log(val);
		//console.log(node.child);
		for (let i in node.child) {
			if (node.child[i].val===val)
				return node.child[i].move;
		}
		return val;
	}
	
	minimax(node, depth, alpha, beta, matrix){
		if (alpha===beta){
			node.val = alpha;
			return alpha;
		}
		if (depth===0) {
			node.val = this.score(matrix);
			return node.val;
		}
		// max
		if (depth%2===0/*node.level%2===0*/) {
			var move = node.move;
			//var lastM = this.lastMove;
			//this.lastMove = move;
			matrix[move.x][move.y] = move.side;
			this.generate(node, this.g.side, depth, matrix);
			var v = alpha;
			for (let i in node.child) {
				node.child[i].val = this.minimax(node.child[i], depth-1, v, beta, matrix);
				if (node.child[i].val > v) {
					v = node.child[i].val;
				}
				if (v >= beta) {
					matrix[move.x][move.y] = 0;
					node.val = beta;
					return beta;
				}
			}
			//this.lastMove = lastM;
			matrix[move.x][move.y] = 0;
			node.val = v;
			return v;
		}
		// min
		if (depth%2===1/*node.level%2===1*/) {
			var move = node.move;
			//var lastM = this.lastMove;
			//this.lastMove = move;
			matrix[move.x][move.y] = move.side;
			this.generate(node, -this.g.side, depth, matrix);
			var v = beta;
			for (let i in node.child) {
				node.child[i].val = this.minimax(node.child[i], depth-1, alpha, v, matrix);
				if (node.child[i].val < v) {
					v = node.child[i].val;
				}
				if (v <= alpha) {
					matrix[move.x][move.y] = 0;
					node.val = alpha;
					return alpha;
				}
			}
			//this.lastMove = lastM;
			matrix[move.x][move.y] = 0;
			node.val = v;
			return v;
		}
		return 0;
	}
	generate(node, side, depth, matrix){
		this.counter++;
		//var wl = [];
		node.child = [];
		
		var conditions = {
			win: [],
			dwin: [],
			step1: [],
			dstep1: [],
			step2: [],
			dstep2: [],
			step3: [],
			dstep3: [],
			step4: [],
			dstep4: []
		};
		
		if (depth > 0) {
			for (let x=0;x<15;x++) {
				for (let y=0;y<15;y++) {
					if (matrix[x][y]===0) {
						var flag = false;
						for (let i in directions) {
							var d = directions[i];
							/*
							if (x+d[0]===this.lastMove.x&&y+d[1]===this.lastMove.y) {
								if (node.child===undefined) node.child = [];
								node.child.push({
									val: undefined,
									move: {
										x: x,
										y: y,
										side: side
									},
									level: node.level + 1
								});
								break;
							}
							*/
							if (matrix[x+d[0]]&&matrix[x+d[0]][y+d[1]]) {
								flag = true;
								break;
							}
						}
						if (flag===true) {
							
							var move = {
								x: x,
								y: y,
								side: side
							};
							var score = this.scoreP(move, matrix);
							if (score >= 10000){
								conditions.win.push(move);
							} else if (score >= 1000){
								conditions.step1.push(move);
							} else if (score >= 250){
								conditions.step2.push(move);
							} else if (score >= 100){
								conditions.step3.push(move);
							} else conditions.step4.push(move);
							
							score = this.scoreP({x: x, y: y, side: -side}, matrix);
							if (score >= 10000){
								conditions.dwin.push(move);
							} else if (score >= 1000){
								conditions.dstep1.push(move);
							} else if (score >= 250){
								conditions.dstep2.push(move);
							} else if (score >= 100){
								conditions.dstep3.push(move);
							} else conditions.dstep4.push(move);
							
						}
					}
				}
			}
		}
		/*
		if (!node.child||!node.child.length) {
			node.child = [];
			console.log('here');
			for (let i in wl) {
				node.child.push({
					val: undefined,
					move: wl[i],
					level: node.level + 1
				});
			}
		}
		*/
		
		if (conditions.win.length) {
			node.child.push({
				val: undefined,
				move: conditions.win[0]
			});
			return;
		} else if (conditions.dwin.length) {
			node.child.push({
				val: undefined,
				move: conditions.dwin[0]
			});
			return;
		} else if (conditions.step1.length) {
			for (let i in conditions.step1) {
				node.child.push({
					val: undefined,
					move: conditions.step1[i]
				});
			}
		} else if (conditions.dstep1.length) {
			for (let i in conditions.dstep1) {
				node.child.push({
					val: undefined,
					move: conditions.dstep1[i]
				});
			}
		} else if (conditions.step2.length) {
			for (let i in conditions.step2) {
				node.child.push({
					val: undefined,
					move: conditions.step2[i]
				});
			}
		} else if (conditions.dstep2.length) {
			for (let i in conditions.dstep2) {
				node.child.push({
					val: undefined,
					move: conditions.dstep2[i]
				});
			}
		} 
		// last steps here
		else if (node.move) {
			
			var lmx = this.lastMove.x;
			var lmy = this.lastMove.y;
			for (let i in directions) {
				let d = directions[i];
				if (matrix[lmx+d[0]]&&matrix[lmx+d[0]][lmy+d[1]]===0) {
					node.child.push({
						val: undefined,
						move: {
							x: lmx+d[0],
							y: lmy+d[1],
							side: side
						}
					});
				}
			}
			
			if (conditions.step3.length) {
				for (let i in conditions.step3) {
					node.child.push({
						val: undefined,
						move: conditions.step3[i]
					});
				}
			}
			if (conditions.dstep3.length) {
				for (let i in conditions.dstep3) {
					node.child.push({
						val: undefined,
						move: conditions.dstep3[i]
					});
				}
			}
			/*
			else if (conditions.step4.length) {
				for (let i in conditions.step4) {
					node.child.push({
						val: undefined,
						move: conditions.step4[i]
					});
				}
			} else if (conditions.dstep4.length) {
				for (let i in conditions.dstep4) {
					node.child.push({
						val: undefined,
						move: conditions.dstep4[i]
					});
				}
			}
			*/
		}
		
		var comp = (a, b) => {
			return this.scoreM(a.move, matrix) - this.scoreM(b.move, matrix);
		};
		if (depth%2===1) comp = -comp;
		node.child.sort(comp);
		//console.log('depth: ', depth, ', num: ', node.child.length);

	}
	
	testminimax(){
		if (!this.lastMove) {
			this.lastMove = {
				x: 0,
				y: 0,
				side: this.g.matrix[0][0]
			};
		}
		var node = {
			val: 0,
			move: this.lastMove,
			level: 0
		};
		this.counter = 0;
		this.minimax(node, 2, -Infinity, Infinity, this.g.matrix);
		console.log(this.counter);
	}
	
}

var ai = new AI('AI-MM2');
ai.init();
ai.run();


module.exports = AI;
